<HTML>
<HEAD><TITLE>CA-Clipper 5.2 . Release Notes - Long Entry</TITLE></HEAD>
<BODY>

<A HREF="ng321b5.html">[&lt;&lt;Previous Entry]</A>
<A HREF="ng32080.html">[^^Up^^]</A>
<A HREF="ng32fb9.html">[Next Entry&gt;&gt;]</A>
<A HREF="menu.html" >[Menu]</A>
<A HREF="info.html">[About The Guide]</A>
<HR>
<PRE>
 <B>1   Compiler Optimizations</B>
--------------------------------------------------------------------------------

     The Clipper compiler in contrast to previous versions of Clipper
     performs three types of optimization to your code.

     <B>.</B>  Shortcutting
     <B>.</B>  Constant folding
     <B>.</B>  Dead code removal

     Optimizations have impact on what code is generated by the compiler
     and therefore what code is actually executed at runtime.  This is
     important since it may affect how your programs operate.

   <B>Shortcutting</B>

     Beginning with Clipper version 5.0, the compiler automatically
     performs optimizations (called <B>shortcutting</B>) on logical
     expressions containing .AND. and .OR. operators.  When an
     expression evaluation is shortcut, it ends when the result becomes
     evident.

     With .AND. this means that &lt;lCondition1&gt; and &lt;lCondition2&gt; are both
     evaluated only when &lt;lCondition1&gt; evaluates to true (.T.).  If
     &lt;lCondition1&gt; evaluates to false (.F.), the .AND. operation is
     false (.F.) and &lt;lCondition2&gt; is therefore <B>not</B> evaluated.  For
     example:

     ? .F. .AND. .T.        // Result: .F.  <B>(shortcut)</B>
     ? .F. .AND. .F.        // Result: .F.  <B>(shortcut)</B>
     ? .T. .AND. .T.        // Result: .T.
     ? .T. .AND. .F.        // Result: .F.

     With .OR. this means that &lt;lCondition1&gt; and &lt;lCondition2&gt; are both
     evaluated only when &lt;lCondition1&gt; evaluates to false (.F.).  If
     &lt;lCondition1&gt; evaluates to true (.T.), the .OR. operation is true
     (.T.) and &lt;lCondition2&gt; is therefore <B>not</B> evaluated.  For
     example:

     ? .T. .OR. .T.         // Result: .T.  <B>(shortcut)</B>
     ? .T. .OR. .F.         // Result: .T.  <B>(shortcut)</B>
     ? .F. .OR. .T.         // Result: .T.
     ? .F. .OR. .F.         // Result: .F.

     If the program (.prg) file is compiled with the /Z option, all
     operands of .AND. and .OR. operators are guaranteed to be evaluated
     at runtime.  Note that the scope of the optimization is the scope
     of the compile.  For example, the following compiler command-line
     suppresses shortcutting for Test.prg:

     C&gt;CLIPPER Test /N /W /Z

   <B>Constant Folding</B>

     In Clipper 5.0, the compiler will perform simple evaluation where
     both operands of a binary operator are constant values.  As an
     example,

     nVar := 1 + 2 + 3

     is generated as nVar := 6.  Likewise,

     cVar := "Hello " + "There"

     is generated as cVar := "Hello There."

   <B>Dead Code Removal</B>

     The Clipper compiler automatically removes statements that never
     execute.  This is referred to as <B>dead code removal</B>.  For
     example, the compiler never generates code for the following
     constructs:

     IF .F.
       &lt;statements&gt;
     ENDIF

     DO WHILE .F.
       &lt;statements&gt;
     ENDDO

     <B>Example:</B>  In the STD.CH, the definition for the extended
     expression version of the SET CURSOR command takes advantage of
     dead code removal to allow a logical command argument to be
     transformed into numeric efficiently:

     #command SET CURSOR (&lt;x&gt;) ;
           =&gt; SETCURSOR( IF(&lt;x&gt;, 1, 0) )

     In this example, depending on whether you specify true (.T.) or
     false (.F.) as the SET CURSOR argument, the compiler generates
     either SETCURSOR(1) or SETCURSOR(0).  The IF() evaluation and the
     non-executed case are removed.
</PRE>
<HR>
This page created by ng2html v1.05, the Norton guide to HTML conversion utility.
Written by <A HREF="http://www.acemake.com/hagbard">Dave Pearson</A>
<HR>
</BODY>
</HTML>
