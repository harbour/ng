<HTML>
<HEAD><TITLE>Class(y) v2.4 - Long Entry</TITLE></HEAD>
<BODY>

<A HREF="ng1b664.html">[&lt;&lt;Previous Entry]</A>
<A HREF="ngbc41.html">[^^Up^^]</A>
<A HREF="ng1c34c.html">[Next Entry&gt;&gt;]</A>
<A HREF="menu.html" >[Menu]</A>
<A HREF="info.html">[About The Guide]</A>
<HR>
<PRE>
  <B>Warning</B>

  Duplicate messages in multiply inherited classes can lead to some very
  subtle problems. Imagine that another method such as move() in the
  BorderedWindow class invoked show() as follows:

    ::show()

  When executing move() for an instance of BorderedWindow, there is no
  problem. However, when executing move() for an instance of BordTextWindow,
  the line above will always result in the default show() method being
  invoked, which in our original example is in the TextWindow class. This
  behavior is likely to be incorrect. There are at least two ways of
  addressing this problem:

  <B>.</B>  Redefine the duplicate message in the subclass, and take appropriate
     action, eg. in BordTextWindow:

      METHOD show
       ::TextWindow:show()
       ::BorderedWindow:show()
      RETURN

     If this kind of contention-handling code is needed repeatedly in a
     class, it is possible that composition rather than inheritance should
     be used to implement that class.

  <B>.</B>  A more extreme technique would be to use scope resolution messages
     throughout the code of the original class. This is unlikely to ever be
     a good solution, but is mentioned for completeness. For example, in
     BorderedWindow:

      METHOD move
       ::BorderedWindow:show()
       ...

     These scope resolution messages would be redundant for instances of
     the BorderedWindow class, but would help to ensure correct behavior in
     multiply inherited subclasses of BorderedWindow.
</PRE>
<HR>
This page created by ng2html v1.05, the Norton guide to HTML conversion utility.
Written by <A HREF="http://www.acemake.com/hagbard">Dave Pearson</A>
<HR>
</BODY>
</HTML>
